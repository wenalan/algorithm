//=============================
// Java
//=============================

// use recursion
public wordBreak(String s, Set<String> dict) {
  if (s == null || s.isEmpty()) return true;

  for (String word : dict) {
    if (word.isEmpty()) continue;

    if (s.startsWith(word) && wordBreak(s.substring(word.length()), dict)
      return true;
  }
  return false;
}


// use dp
public class Solution {
    /**
     * @param s: A string s
     * @param dict: A dictionary of words dict
     */
    public boolean wordBreak(String s, Set<String> dict) {
        // write your code here 
        if (s == null || s.isEmpty()) return true;
        
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        
        for (int i = 0; i < s.length(); i++) {
            for (int j = i; j >= 0; j--) {
                if (dp[j] && dict.contains(s.substring(j, i + 1))) {
                    dp[i + 1] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}



//=============================
// C++
//=============================

// use recursion

class Solution {
public:
    /**
     * @param s: A string s
     * @param dict: A dictionary of words dict
     */
    bool wordBreak(string s, unordered_set<string> &dict) {
        // write your code here
        if (s.empty()) return true;
        
        // no need to check dict, if it is empty
        // it will skip the next for()
        // if check, it must check after s.empty()
        // as empty string can be break by empty dict
        //if (dict.empty()) return false;
        
        for (auto word : dict) {
            // don't forget to skip the case of empty word!
            if (word.empty()) continue;
            
            if (s.find(word) == 0) {
                // only return when recursion return true
                // but not directly return the result of recursion!
                if (wordBreak(s.substr(word.size()), dict)) return true;
            }
        }
        return false;
    }
};


/*
use dp

use the following test case to help remember the process
pay attention at position ^

 01234567
 testword
TFFFT
01234
    ^
*/

class Solution {
public:
    /**
     * @param s: A string s
     * @param dict: A dictionary of words dict
     */
    bool wordBreak(string s, unordered_set<string> &dict) {
        // write your code here
        if (s.empty()) return true;
        
        vector<bool> dp(s.size() + 1);
        dp[0] = true;
        
        for (int i = 0; i < s.size(); i++) {
            for (int j = i; j >= 0; j--) {
                if (dp[j] && dict.count(s.substr(j, i - j + 1))) {
                    dp[i + 1] = true;
                }
            }
        }
        return dp[s.size()];
    }
};
